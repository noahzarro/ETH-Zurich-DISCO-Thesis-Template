\documentclass[a4paper, oneside]{discothesis}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{minted}
\usepackage{xcolor}

\definecolor{LightGray}{gray}{0.9}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% DOCUMENT METADATA

\thesistype{Semester Thesis} % Master's Thesis, Bachelor's Thesis, Semester Thesis, Group Project
\title{Thesis Title}

\author{Noah Zarro}
\email{zarron@ethz.ch}

\institute{Distributed Computing Group \\[2pt]
Computer Engineering and Networks Laboratory \\[2pt]
ETH ZÃ¼rich}

% Optionally, you can put in your own logo here
\logo{\includegraphics[width=0.2\columnwidth]{figures/logo_black.png}}

\supervisors{Ard Kastrati, Karolis Martinkus\\[2pt] Prof.\ Dr.\ Roger Wattenhofer}

% Optionally, keywords and categories of the work can be shown (on the Abstract page)
%\keywords{Keywords go here.}
%\categories{ACM categories go here.}

\date{\today}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}

\frontmatter % do not remove this line
\maketitle

\cleardoublepage

\begin{acknowledgements}

\end{acknowledgements}


\begin{abstract}

\end{abstract}

\tableofcontents

\mainmatter % do not remove this line

% Start writing here

\chapter{Motivation}
On the 7th of January this year, Elon Musk tweeted the following two words: "Use Signal!" \cite{Twitter}. It was a tweet with lots of consequences. First, it caused the stock prices of the totally unrelated company \emph{Signal Advance} to skyrocket. Secondly, and more relevant for this paper, it once again fueled the discussion about personal messengers. The tweet was a reaction to the announcement of WhatsApp's new terms and conditions, that once again weakened the privacy of its users. Soon after, WhatsApp's competitors were able to report rapid increases of users.

But there are immense differences among the other players in the market of personal messengers. It is worth a closer look, see table \ref{table:messengers}. When switching from WhatsApp to another app, there are two reasonable options: Either Telegram, that convinces with its cloud, which means if one loses his phone, previously sent messages are preserved. But it does not offer E2E-Encryption, except for unhandy peer to peer, device locked chats, which are not cloud based. However, it provides by far the most features, such as bots, custom clients, GIFs, etc. On the other hand, Signal is considered the most secure messenger of the four in question, since it provides forward secrecy, automatic \emph{healing} after one round trip if keys were leaked, groups members that are anonymous to the server, etc. Threema however does neither offer forward secrecy, nor cloud, and it is not free of charge, so there is no real unique selling point to it.

But if one wants to have a cloud-based messenger that is also \REMARK{shall abbreviations be used?} E2E-encrypted, there is currently no option. This thesis aims to solve this problem, by presenting an app that provides both features. But since there are already that many messengers, an app is presented, that acts as a client for multiple, not E2E encrypted, but cloud-based messenger services, and adds an encryption layer to them. For a start, the client does support just Telegram, but additional messengers, like Facebook, could be added easily.


\begin{table}[h!]
\centering
\begin{center}
 \begin{tabular}{|| c ||c c c c||} 
  \hline
 \multicolumn{5}{|c|}{Popular Messengers} \\
 \hline
 \hline
   & WhatsApp & Telegram & Threema & Signal \\ [0.5ex] 
 \hline\hline
 Users (M) & 2'000 & 500 & 10 & 40 \\ 
 \hline
 E2E-Encryption & claimed & no & yes & yes \\
 \hline
 Forward Secrecy & claimed & no & no & yes \\
 \hline
 Cloud & backup & yes & no & no \\
 \hline
 Open Source & no & yes (client) & yes & yes \\
 \hline
\end{tabular}
\end{center}
\caption{Sources: \cite{Business, Statistia}}
\label{table:messengers}
\end{table}


\chapter{Protocol}

\section{Overview}
The goal of the concept is to provide an E2E-encryption overlay for a generic cloud based messenger, like Telegram or Facebook Messenger. There are several desired properties:
\begin{enumerate}
  \item A user should be able to log in from different devices with the same account and see all previously sent messages. 
  \item The cloud infrastructure of the underlying messenger should be used for messages.
  \item Peer to peer chats and group chats should be E2E-encrypted.
\end{enumerate}

In the following, the details of the concept are elaborated. First, it is explained how the cloud feature is achieved, in the next part, the basic peer to peer encryption is introduced, and the final part covers the encryption of group chats.

\section{Cloud}

Since an existing, cloud-based messenger should be used, all messages must be saved on its server. In the implementation, Telegram was used as a base messenger. Therefore, the protocol needs a custom client, that can encrypt and decrypt messages and exchange them with the server. So far it resembles a generic end-to-end encrypted messenger, as there are many on the market, like WhatsApp, Signal and Threema. But since the underlying messenger is cloud based, the client should be able to log in from multiple devices and see the same messages. There are two main ways to solve this problem.

\subsection{Mulitple Keys}

One approach, which Signal followed in the Sesame protocol \cite{Sesame}, is to create an artificial "group" chat with all devices of a user and its peer as members, in which a message is sent to each member individually. In this approach, each device has a unique key, and if a message is sent from one device, it is encrypted once for each other device in the "group". These messages are then sent to the corresponding devices and stored locally. The problem with this approach is that, if a new device is registered, it cannot decrypt previously sent messages, because at the time of sending, the sender did not know about the new device, and therefore did not encrypt the message for it. Another problem is, that if the messages are saved in the cloud, $\mathcal{O}(devices)$ space is needed per message on the server.

\subsection{Shared Key}

The other approach is that once an account is created, a unique key is generated, which is shared across the devices. The advantage of this approach is that devices can drop in and out at will, and can always decrypt all messages. The disadvantage is that forward security is no longer guaranteed. This comes from the fact that any message sent in the past must be decryptable by a newly added device in the future. This directly contradicts with the definition of forward secrecy. The topic gets further discussed in section \ref{sec:forward_secrecy}. Because this approach provides much more flexibility, and also uses less space on the server, it was chosen for the protocol.

\subsection{Keyserver}

When shared keys are used, the problem arises of how they are distributed. This can be solved by storing them in a key server. Naturally, the stored keys should not be accessible by the key server, otherwise the user would just have to trust the key server instead of Telegram. Therefore, the stored keys are encrypted by a single symmetric master key, that has to be transferred manually between devices, and is only stored locally on the devices of the user. Theoretically, user authentication against the key server could be left out, because the encrypted keys are no use to anyone without the symmetric master key. But to add redundancy, the user has to authenticate itself to the server, using an asymmetric authentication key pair. This second key also has to be transferred manually between devices.


\begin{figure}[h!]
    \centering
    \includegraphics[width=\columnwidth]{figures/structure.png}
    \caption{Key Server Setup}
    \label{fig:structure}
\end{figure}




\section{Peer to Peer}
To encrypt a single message, a static symmetric key is used, that is known to both peers. The message is encrypted with the \emph{XSalsa20} algorithm, as used by Threema \cite{Threema}. The key is acquired through a Diffie-Hellman key exchange, also as in the Threema protocol, see fig \ref{fig:peer_encryption}.

\begin{figure}[h!]
    \centering
    \includegraphics[width=\columnwidth]{figures/threema.png}
    \caption{The Peer to Peer encryption of Threema}
    \label{fig:peer_encryption}
\end{figure}

\subsection{Forward Secrecy}
\label{sec:forward_secrecy}

Currently, the most popular messengers have different approaches concerning forward secrecy. Signal and WhatsApp \REMARK{Are brackets ok?} (which uses the Signal protocol), have a very sophisticated and utterly clever system, where after every message round trip, the symmetric encryption key is changed in a way, that if this specific version of the key is leaked, only the messages from the current round trip can be decrypted, but not past nor future messages. This is achieved by recursively hashing the key after every round trip, and combining it with a new Diffie-Hellman key exchange after every round \cite{DoubleRatchet}.

In their device bound secret chats, Telegram does a re-keying after each 100 messages, and Threema refrains from implementing forward secrecy at all \cite{Threema}.

For the presented protocol, however, forward secrecy is not possible by design. Because a newly added device must be able to decrypt all previously sent messages in the cloud, forward secrecy cannot be achieved, because by definition in a forward secure system, a message should no longer be decryptable after it was sent and received once.

\subsection{Key Exchange}

For a Diffie-Hellman key exchange, classically two parties execute a synchronous protocol. But since in the context of mobile messaging this is not feasible, the protocol has to be made asynchronously. The proposed way is the de facto standard among modern E2E-encrypted messengers. First, both parties publish their public key part on an openly accessible server, here the key server is used. If party A wants to negotiate a key, it fetches the public key part of party B from the server, constructs the shared secret, and can already send the first messages. As soon as party B gets online, it can fetch party A's public key and also construct the same shared secret. The newly constructed symmetric keys are then saved on the key server. They could also easily be recreated each time a new device is added, but this way, as soon as the symmetric key was negotiated, user A is independent of user B. Even if user B deletes its account, user A can still decrypt the old messages.

\section{Groups}

Group chats are a bit more complex than peer to peer chats. Therefore, the existing messengers have different approaches to solve it.

\subsection{Threema}

Threema uses \emph{client side fan out}, a straight forward approach, where a group member sends group messages directly through peer to peer chats to the corresponding group members. The messages are tagged with the group ID. This approach is very easy, but it does not scale well, especially if the messages should be saved in the cloud. The used space per message is $\mathcal{O}(n)$, where $n$ are the number of group members \cite{Threema}. Because of this, for messages containing media, another approach was chosen, where the media is encrypted with a single symmetric key, which is distributed like a normal text message in the group. The media file is then stored on the Threema server until everybody has fetched it, or a timeout is reached.

\subsection{Signal/Whatsapp}

It is not perfectly clear, how Signal and WhatsApp handle their group messages. In a blog post from 2014 Signal states that their group encryption also implements client side fan out, as Threema does \cite{SignalGroupsOld}. On the other hand, WhatsApp claims to use the Signal protocol, and in their white paper they describe a server side fan out system, where a group member first generates a random symmetric key, and sends it in a normal peer to peer chat to the other group members. The following messages are then encrypted with the symmetric key and sent to the server, which forwards it to each group member\cite{Whatsapp}. The symmetric key can then be ratched (hashed), as in the peer to peer communication, to provide forward secrecy. Additionally, the messages are signed with an asymmetric key, to provide authenticity. However, Signal does not specify any changes to their group protocol, and the server side fan out approach does not go well with the philosophy of Signal, whose goal it is to know as little as possible about the users, including group constellations \cite{SignalGroupsNew}. Therefore, it is possible that WhatsApp only uses the Signal protocol for the peer to peer messages, and developed their own protocol for group chats.

\subsection{Proposition}
On the base of the above protocols, a new one was proposed, which is optimized for the use as an overlay to a cloud based messenger.

\subsubsection{Client Side Fan Out}
\label{sec:server_side_fan_out}

One approach would be to encrypt each message separately, and send them either over the classic peer to peer channel, with the group ID as a tag, or concatenate all encrypted version of the same message and send them as one large message in the group chat. The first option was discarded because it would mix the peer to peer chats with the group chats, which would add unnecessary complexity to the protocol. The second approach was also discarded, because it scales badly. Since text messages are relatively small, it would not be impossible, but it is also not very clean.

However, with both approaches, no additional measures are needed to handle the joining or leaving of group members. Since the group constellation is always known by the Telegram servers anyway, members could just encrypt their messages only for the current members of the group. It only leaves room for a relative harmless attack. A group member could just encrypt its message for everyone except one or more group members, and like this exclude them from the conversation. This however would be easily detectable by the affected members, and they could complain in the group chat. 

\subsubsection{Server Side Fan Out}

Another approach would be to use a single symmetric key for the group chat that is shared among all members. Like this, if a member wants to send a message, it would encrypt it only once, and send this message in the group chat.

With this approach, two problems arise. First, the symmetric key must be distributed among the members, and secondly, the key must be changed if the group constellation changes.

To solve the first problem, two solutions are proposed. Either a new key is encrypted with each peer to peer symmetric key, as the messages in \ref{sec:server_side_fan_out}, and all encrypted keys are concatenated and sent into the group chat. This solution was discarded, because it would violate the separation of messages in the Telegram cloud and keys on the key server. The second and finally chosen solution, is to publish the set of individually encrypted keys on the key server. The key server holds a list for each group, where anyone who can authenticate itself can append a new set of encrypted keys, together with the user ID of the poster. Since the server has no access to Telegrams group structure, it cannot check who is in which group. Therefore, it is the client's obligation to check if the latest key was really added by a group member. If not, it just fetches the second-latest key.

The problem of key renegotiation on joining or leaving was not completely solved yet due to time constraints, but it is discussed in the chapter Future Work \ref{sec:future_work}.


\chapter{Implementation}




\section{Keyserver}

The key server is implemented in TypeScript and runs on Node.js. This has the advantage that the same language is used as for the app, and therefore the same libraries can be used in some cases. It is reachable under the domain \texttt{athena.eth-lerngruppe.ch}. The TypeScript framework used for the server is Express \cite{Express}. In this section, the most important concepts are described, a detailed API description can be found in the appendix \todo{put it into the appendix}.

\subsection{Keys}

\label{sec:keys}

Since many different keys are used in the protocol, first a short overview is presented, where the name, the purpose and the used algorithm of each key is specified. Variables containing only the public part of a key are prepended by a \texttt{public\_} prefix. Variables containing the whole key, including the private part, are tagged with a \texttt{private\_} prefix.

\subsubsection{Authorization Key}

Name: \texttt{auth}

\noindent
Algorithm: ES512

\noindent
Usage: To authenticate to the key server

\noindent
Storage: Public part on the server, private party in the app

\subsubsection{Key Encryption Key}

Name: \texttt{sym}

\noindent
Algorithm: A256GCM

\noindent
Usage: To encrypt keys to store them on the key server

\noindent
Storage: In the app

\subsubsection{Group Key}

Name: \texttt{group}

\noindent
Algorithm: ECDH-ES, on curve P-521

\noindent
Usage: The public key is used by another group member to encrypt a new symmetric group key, which then can be decrypted by the owner of the private key.

\noindent
Storage: The public part publicly on the key server, the private part encrypted with \texttt{sym} on the key server.

\subsubsection{Peer Diffie-Hellman Key}

Name: \texttt{enc}

\noindent
Algorithm: ECDH, on curve 25519

\noindent
Usage: The public key is used by another user to agree on a symmetric key for peer to peer communication.

\noindent
Storage: The public part publicly on the key server, the private part encrypted with \texttt{sym} on the key server.

\subsection{Authentication}

To authenticate to the server, a token based system is used. In the following, the steps necessary to access a resource on the server are described.

\subsubsection{Account Creation}

On first use, an account has to be created. In the process, all keys specified in Section \ref{sec:keys} are created in the app. All keys except \texttt{private\_auth} and \texttt{sym} are sent to the server, see Lst. \ref{lst:new_account}. The server saves the received keys, generates and returns a unique ID for the user.

\begin{listing}[h!]
\label{lst:new_account}
\begin{minted}[frame=lines, linenos]{typescript}
{
    // public auth key of client
    "public_auth": "<key in pem format>",
    // public enc key of client
    "public_enc": "<key in base64>",
    // private encryption key of client, encrypted with auth
    "private_enc": "<key encrypted, in base64>",
    // used for symmetric group key encryption
    "public_group": "<key in JWK flattened format>",
    // used for symmetric group key decryption
    "private_group": "<key encrypted, JWE flattened format>" 
}
\end{minted}
\caption{JSON object sent to the key server on account generation}
\end{listing}

\subsubsection{Token Aquistion}

All requests to the server, except for the account creation and the token acquisition requests, need to be authenticated. This is achieved by sending a JSON Web Token (JWT) with each request. To acquire this token, a user must complete a challenge, given by the server. The client first requests a nonce from the server, and creates a JSON Web Signature (JWS) object, that contains its ID and the nonce received previously by the server. This JWS is signed with the users \texttt{auth} key and sent to the server.

The server checks if the signature is valid for the \texttt{public\_auth} key saved for the ID of the sender. If the signature is valid, the server issues a JWT containing, the ID of the user and the expiration date, signed with the servers private \texttt{ed25519} key. Tokens are valid for two hours.

\subsubsection{Token Check}

Each time a user performs a request that has to be authenticated, a token must be added. The token is sent in the \texttt{authorization} header field, with the syntax \texttt{Bearer: <token>}.

\subsection{Data Structure}

\subsection{Group Keys}

\section{App}
asdfasdfasdfasdf
\chapter{Future Work}
\label{sec:future_work}

\section{In Platform Authentication}

\section{Group Modifications}

% This displays the bibliography for all cited external documents. All references have to be defined in the file references.bib and can then be cited from within this document.
\bibliographystyle{IEEEtran}
\bibliography{references}

% This creates an appendix chapter, comment if not needed.
\appendix
\chapter{First Appendix Chapter Title}

\end{document}