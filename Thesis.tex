\documentclass[a4paper, oneside]{discothesis}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{minted}
\usepackage{xcolor}

\definecolor{LightGray}{gray}{0.9}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% DOCUMENT METADATA

\thesistype{Semester Thesis} % Master's Thesis, Bachelor's Thesis, Semester Thesis, Group Project
\title{Thesis Title}

\author{Noah Zarro}
\email{zarron@ethz.ch}

\institute{Distributed Computing Group \\[2pt]
Computer Engineering and Networks Laboratory \\[2pt]
ETH ZÃ¼rich}

% Optionally, you can put in your own logo here
\logo{\includegraphics[width=0.2\columnwidth]{figures/logo_black.png}}

\supervisors{Ard Kastrati, Karolis Martinkus\\[2pt] Prof.\ Dr.\ Roger Wattenhofer}

% Optionally, keywords and categories of the work can be shown (on the Abstract page)
%\keywords{Keywords go here.}
%\categories{ACM categories go here.}

\date{\today}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}

\frontmatter % do not remove this line
\maketitle

\cleardoublepage

\begin{acknowledgements}

\end{acknowledgements}


\begin{abstract}

\end{abstract}

\tableofcontents

\mainmatter % do not remove this line

% Start writing here

\chapter{Motivation}
On the 7th of January this year, Elon Musk tweeted the following two words: "Use Signal!" \cite{Twitter}. It was a tweet with lots of consequences. First, it caused the stock prices of the totally unrelated company \emph{Signal Advance} to skyrocket. Secondly, and more relevant for this paper, it once again fueled the discussion about personal messengers. The tweet was a reaction to the announcement of WhatsApp's new terms and conditions, that once again weakened the privacy of its users. Soon after, WhatsApp's competitors were able to report rapid increases of users.

But there are immense differences among the other players in the market of personal messengers. It is worth a closer look, see table \ref{table:messengers}. When switching from WhatsApp to another app, there are two reasonable options: Either Telegram, that convinces with its cloud, which means if one loses his phone, previously sent messages are preserved. But it does not offer E2E-Encryption, except for unhandy peer to peer, device locked chats, which are not cloud based. However, it provides by far the most features, such as bots, custom clients, GIFs, etc. On the other hand, Signal is considered the most secure messenger of the four in question, since it provides forward secrecy, automatic \emph{healing} after one round trip if keys were leaked, groups members that are anonymous to the server, etc. Threema however does neither offer forward secrecy, nor cloud, and it is not free of charge, so there is no real unique selling point to it.

But if one wants to have a cloud-based messenger that is also \REMARK{shall abbreviations be used?} E2E-encrypted, there is currently no option. This thesis aims to solve this problem, by presenting an app that provides both features. But since there are already that many messengers, an app is presented, that acts as a client for multiple, not E2E encrypted, but cloud-based messenger services, and adds an encryption layer to them. For a start, the client does support just Telegram, but additional messengers, like Facebook, could be added easily.


\begin{table}[h!]
\centering
\begin{center}
 \begin{tabular}{|| c ||c c c c||} 
  \hline
 \multicolumn{5}{|c|}{Popular Messengers} \\
 \hline
 \hline
   & WhatsApp & Telegram & Threema & Signal \\ [0.5ex] 
 \hline\hline
 Users (M) & 2'000 & 500 & 10 & 40 \\ 
 \hline
 E2E-Encryption & claimed & no & yes & yes \\
 \hline
 Forward Secrecy & claimed & no & no & yes \\
 \hline
 Cloud & backup & yes & no & no \\
 \hline
 Open Source & no & yes (client) & yes & yes \\
 \hline
\end{tabular}
\end{center}
\caption{Sources: \cite{Business, Statistia}}
\label{table:messengers}
\end{table}


\chapter{Protocol}

\section{Overview}
The goal of the concept is to provide an E2E-encryption overlay for a generic cloud based messenger, like Telegram or Facebook Messenger. There are several desired properties:
\begin{enumerate}
  \item A user should be able to log in from different devices with the same account and see all previously sent messages. 
  \item The cloud infrastructure of the underlying messenger should be used for messages.
  \item Peer to peer chats and group chats should be E2E-encrypted.
\end{enumerate}

In the following, the details of the concept are elaborated. First, it is explained how the cloud feature is achieved, in the next part, the basic peer to peer encryption is introduced, and the final part covers the encryption of group chats.

\section{Cloud}

Since an existing, cloud-based messenger should be used, all messages must be saved on its server. In the implementation, Telegram was used as a base messenger. Therefore, the protocol needs a custom client, that can encrypt and decrypt messages and exchange them with the server. So far it resembles a generic end-to-end encrypted messenger, as there are many on the market, like WhatsApp, Signal and Threema. But since the underlying messenger is cloud based, the client should be able to log in from multiple devices and see the same messages. There are two main ways to solve this problem.

\subsection{Mulitple Keys}

One approach, which Signal followed in the Sesame protocol \cite{Sesame}, is to create an artificial "group" chat with all devices of a user and its peer as members, in which a message is sent to each member individually. In this approach, each device has a unique key, and if a message is sent from one device, it is encrypted once for each other device in the "group". These messages are then sent to the corresponding devices and stored locally. The problem with this approach is that, if a new device is registered, it cannot decrypt previously sent messages, because at the time of sending, the sender did not know about the new device, and therefore did not encrypt the message for it. Another problem is, that if the messages are saved in the cloud, $\mathcal{O}(devices)$ space is needed per message on the server.

\subsection{Shared Key}

The other approach is that once an account is created, a unique key is generated, which is shared across the devices. The advantage of this approach is that devices can drop in and out at will, and can always decrypt all messages. The disadvantage is that forward security is no longer guaranteed. This comes from the fact that any message sent in the past must be decryptable by a newly added device in the future. This directly contradicts with the definition of forward secrecy. The topic gets further discussed in section \ref{sec:forward_secrecy}. Because this approach provides much more flexibility, and also uses less space on the server, it was chosen for the protocol.

\subsection{Keyserver}

When shared keys are used, the problem arises of how they are distributed. This can be solved by storing them in a key server. Naturally, the stored keys should not be accessible by the key server, otherwise the user would just have to trust the key server instead of Telegram. Therefore, the stored keys are encrypted by a single symmetric master key, that has to be transferred manually between devices, and is only stored locally on the devices of the user. Theoretically, user authentication against the key server could be left out, because the encrypted keys are no use to anyone without the symmetric master key. But to add redundancy, the user has to authenticate itself to the server, using an asymmetric authentication key pair. This second key also has to be transferred manually between devices.


\begin{figure}[h!]
    \centering
    \includegraphics[width=\columnwidth]{figures/structure.png}
    \caption{Key Server Setup}
    \label{fig:structure}
\end{figure}




\section{Peer to Peer}
To encrypt a single message, a static symmetric key is used, that is known to both peers. The message is encrypted with the \emph{XSalsa20} algorithm, as used by Threema \cite{Threema}. The key is acquired through a Diffie-Hellman key exchange, also as in the Threema protocol, see fig \ref{fig:peer_encryption}.

\begin{figure}[h!]
    \centering
    \includegraphics[width=\columnwidth]{figures/threema.png}
    \caption{The Peer to Peer encryption of Threema}
    \label{fig:peer_encryption}
\end{figure}

\subsection{Forward Secrecy}
\label{sec:forward_secrecy}

Currently, the most popular messengers have different approaches concerning forward secrecy. Signal and WhatsApp \REMARK{Are brackets ok?} (which uses the Signal protocol), have a very sophisticated and utterly clever system, where after every message round trip, the symmetric encryption key is changed in a way, that if this specific version of the key is leaked, only the messages from the current round trip can be decrypted, but not past nor future messages. This is achieved by recursively hashing the key after every round trip, and combining it with a new Diffie-Hellman key exchange after every round \cite{DoubleRatchet}.

In their device bound secret chats, Telegram does a re-keying after each 100 messages, and Threema refrains from implementing forward secrecy at all \cite{Threema}.

For the presented protocol, however, forward secrecy is not possible by design. Because a newly added device must be able to decrypt all previously sent messages in the cloud, forward secrecy cannot be achieved, because by definition in a forward secure system, a message should no longer be decryptable after it was sent and received once.

\subsection{Key Exchange}

For a Diffie-Hellman key exchange, classically two parties execute a synchronous protocol. But since in the context of mobile messaging this is not feasible, the protocol has to be made asynchronously. The proposed way is the de facto standard among modern E2E-encrypted messengers. First, both parties publish their public key part on an openly accessible server, here the key server is used. If party A wants to negotiate a key, it fetches the public key part of party B from the server, constructs the shared secret, and can already send the first messages. As soon as party B gets online, it can fetch party A's public key and also construct the same shared secret. The newly constructed symmetric keys are then saved on the key server. They could also easily be recreated each time a new device is added, but this way, as soon as the symmetric key was negotiated, user A is independent of user B. Even if user B deletes its account, user A can still decrypt the old messages.

\section{Groups}

Group chats are a bit more complex than peer to peer chats. Therefore, the existing messengers have different approaches to solve it.

\subsection{Threema}

Threema uses \emph{client side fan out}, a straight forward approach, where a group member sends group messages directly through peer to peer chats to the corresponding group members. The messages are tagged with the group ID. This approach is very easy, but it does not scale well, especially if the messages should be saved in the cloud. The used space per message is $\mathcal{O}(n)$, where $n$ are the number of group members \cite{Threema}. Because of this, for messages containing media, another approach was chosen, where the media is encrypted with a single symmetric key, which is distributed like a normal text message in the group. The media file is then stored on the Threema server until everybody has fetched it, or a timeout is reached.

\subsection{Signal/Whatsapp}

It is not perfectly clear, how Signal and WhatsApp handle their group messages. In a blog post from 2014 Signal states that their group encryption also implements client side fan out, as Threema does \cite{SignalGroupsOld}. On the other hand, WhatsApp claims to use the Signal protocol, and in their white paper they describe a server side fan out system, where a group member first generates a random symmetric key, and sends it in a normal peer to peer chat to the other group members. The following messages are then encrypted with the symmetric key and sent to the server, which forwards it to each group member\cite{Whatsapp}. The symmetric key can then be ratched (hashed), as in the peer to peer communication, to provide forward secrecy. Additionally, the messages are signed with an asymmetric key, to provide authenticity. However, Signal does not specify any changes to their group protocol, and the server side fan out approach does not go well with the philosophy of Signal, whose goal it is to know as little as possible about the users, including group constellations \cite{SignalGroupsNew}. Therefore, it is possible that WhatsApp only uses the Signal protocol for the peer to peer messages, and developed their own protocol for group chats.

\subsection{Proposition}
On the base of the above protocols, a new one was proposed, which is optimized for the use as an overlay to a cloud based messenger.

\subsubsection{Client Side Fan Out}
\label{sec:server_side_fan_out}

One approach would be to encrypt each message separately, and send them either over the classic peer to peer channel, with the group ID as a tag, or concatenate all encrypted version of the same message and send them as one large message in the group chat. The first option was discarded because it would mix the peer to peer chats with the group chats, which would add unnecessary complexity to the protocol. The second approach was also discarded, because it scales badly. Since text messages are relatively small, it would not be impossible, but it is also not very clean.

However, with both approaches, no additional measures are needed to handle the joining or leaving of group members. Since the group constellation is always known by the Telegram servers anyway, members could just encrypt their messages only for the current members of the group. It only leaves room for a relative harmless attack. A group member could just encrypt its message for everyone except one or more group members, and like this exclude them from the conversation. This however would be easily detectable by the affected members, and they could complain in the group chat. 

\subsubsection{Server Side Fan Out}

Another approach would be to use a single symmetric key for the group chat that is shared among all members. Like this, if a member wants to send a message, it would encrypt it only once, and send this message in the group chat.

With this approach, two problems arise. First, the symmetric key must be distributed among the members, and secondly, the key must be changed if the group constellation changes.

To solve the first problem, two solutions are proposed. Either a new key is encrypted with each peer to peer symmetric key, as the messages in \ref{sec:server_side_fan_out}, and all encrypted keys are concatenated and sent into the group chat. This solution was discarded, because it would violate the separation of messages in the Telegram cloud and keys on the key server. The second and finally chosen solution, is to publish the set of individually encrypted keys on the key server. The key server holds a list for each group, where anyone who can authenticate itself can append a new set of encrypted keys, together with the user ID of the poster. Since the server has no access to Telegrams group structure, it cannot check who is in which group. Therefore, it is the client's obligation to check if the latest key was really added by a group member. If not, it just fetches the second-latest key.

The problem of key renegotiation on joining or leaving was not completely solved yet due to time constraints, but it is discussed in the chapter Future Work \ref{sec:future_work}.


\chapter{Implementation}




\section{Keyserver}

The key server is implemented in TypeScript and runs on Node.js. This has the advantage that the same language is used as for the app, and therefore the same libraries can be used in some cases. It is reachable under the domain \texttt{athena.eth-lerngruppe.ch}. The TypeScript framework used for the server is Express \cite{Express}. In this section, the most important concepts are described, a detailed API description can be found in the appendix \todo{put it into the appendix}.

\subsection{Keys}

\label{sec:keys}

Since many different keys are used in the protocol, first a short overview is presented, where the name, the purpose and the used algorithm of each key is specified. Variables containing only the public part of a key are prepended by a \texttt{public\_} prefix. Variables containing the whole key, including the private part, are tagged with a \texttt{private\_} prefix.

\subsubsection{Authorization Key}

Name: \texttt{auth}

\noindent
Algorithm: ES512

\noindent
Usage: To authenticate to the key server

\noindent
Storage: Public part on the server, private party in the app

\subsubsection{Key Encryption Key}

Name: \texttt{sym}

\noindent
Algorithm: A256GCM

\noindent
Usage: To encrypt keys to store them on the key server

\noindent
Storage: In the app

\subsubsection{Group Key}

Name: \texttt{group}

\noindent
Algorithm: ECDH-ES, on curve P-521

\noindent
Usage: The public key is used by another group member to encrypt a new symmetric group key, which then can be decrypted by the owner of the private key.

\noindent
Storage: The public part publicly on the key server, the private part encrypted with \texttt{sym} on the key server.

\subsubsection{Peer Diffie-Hellman Key}

Name: \texttt{enc}

\noindent
Algorithm: ECDH, on curve 25519

\noindent
Usage: The public key is used by another user to agree on a symmetric key for peer to peer communication.

\noindent
Storage: The public part publicly on the key server, the private part encrypted with \texttt{sym} on the key server.

\subsection{Authentication}

To authenticate to the server, a token based system is used. In the following, the steps necessary to access a resource on the server are described.

\subsubsection{Account Creation}

On first use, an account has to be created. In the process, all keys specified in Section \ref{sec:keys} are created in the app. All keys except \texttt{private\_auth} and \texttt{sym} are sent to the server, see Lst. \ref{lst:new_account}. The server saves the received keys, generates and returns a unique ID for the user.

\begin{listing}[h!]
\label{lst:new_account}
\begin{minted}[frame=lines, linenos]{typescript}
{
    // public auth key of client
    "public_auth": "<key in pem format>",
    // public enc key of client
    "public_enc": "<key in base64>",
    // private encryption key of client, encrypted with auth
    "private_enc": "<key encrypted, in base64>",
    // used for symmetric group key encryption
    "public_group": "<key in JWK flattened format>",
    // used for symmetric group key decryption
    "private_group": "<key encrypted, JWE flattened format>" 
}
\end{minted}
\caption{JSON object sent to the key server on account generation}
\end{listing}

\subsubsection{Token Aquistion}

All requests to the server, except for the account creation and the token acquisition requests, need to be authenticated. This is achieved by sending a JSON Web Token (JWT) with each request. To acquire this token, a user must complete a challenge, given by the server. The client first requests a nonce from the server, and creates a JSON Web Signature (JWS) object, that contains its ID and the nonce received previously by the server. This JWS is signed with the users \texttt{auth} key and sent to the server.

The server checks if the signature is valid for the \texttt{public\_auth} key saved for the ID of the sender. If the signature is valid, the server issues a JWT containing, the ID of the user and the expiration date, signed with the servers private \texttt{ed25519} key. Tokens are valid for two hours.

\subsubsection{Token Check}

Each time a user performs a request that has to be authenticated, a token must be added. The token is sent in the \texttt{authorization} header field, with the syntax \texttt{Bearer: <token>}. The server checks the validity of the signature, and if the token is not expired.

\subsection{Data Structure}

In the current state of the project, the user data is stored in two simple JSON files, \texttt{users.json} and \texttt{groups.json}. This makes it easier to debug. For scalability, a switch to a real database would be appropriate. Requests are handled sequentially, without threading, to prevent race conditions.

\subsubsection{Users}

The \texttt{users.json} file consists of a list of user objects, specified in Lst. \ref{lst:users}. The user type contains a unique user ID, the keys transmitted during the account generation, optional IDs for Telegram or Facebook (which was not implemented, but would be in the next version) and an array of sessions, that contains the keys for peer to peer communications. The session keys are encrypted with \texttt{private\_auth}.

There are specific requests to populate the Telegram and Facebook fields. They are called as soon as the users logs into its Telegram account in the app.

The session keys are explained in more detail in \todo{Add ref to session details}


\begin{listing}[h!]
\label{lst:users}
\begin{minted}[frame=lines, linenos]{typescript}
type Session = {
    "peer": string,
    "symmetric": string
}

type User = {
    "uuid": string,
    "public_auth": string,
    "public_enc": string,
    "private_enc": string,
    "public_group": string,
    "private_group": string,
    "sessions": Session[],
    "telegram"?: string,
    "facebook"?: string
};
\end{minted}
\caption{User objects, saved in \texttt{users.json}}
\end{listing}

\subsubsection{Groups}
\label{sec:group_keys}

The \texttt{groups.json} contains an entry for each group, that specifies its ID, and the platform the group was created in (e.g. Telegram). This entry also contains a list of \texttt{GroupPosts}, as described in Lst. \ref{lst:groups}. A group post are created each time a new symmetric key is generated for this group. The symmetric key is then encrypted for each group member, and the resulting set is saved in the \texttt{group} field of the \texttt{GroupPost}. This process is explained in more detail in Section \todo{Add ref to group key generation}

\begin{listing}[h!]
\label{lst:groups}
\begin{minted}[frame=lines, linenos]{typescript}
type GroupPost = {
    "from": string,
    "date": string
    "keys": GroupKey[] // entry for each group member
}

type GroupKey = {
    "uuid": string,
    "key": string // encrypted with user uuid's public_group key
}
\end{minted}
\caption{Group objects, saved in \texttt{groups.json}}
\end{listing}

\section{App}

The app was implemented with Ionic, using the Angular and Cordova framework \cite{Ionic}. It is a framework that allows the developer to compile a website to an app. Therefore, it is easy to develop cross-platform apps.  

\subsection{Structure}

The app is structured in three layers. The first layer, which is represented by the \texttt{KeyServerService}, handles the communication with the key server, and provides an interface to access the various keys. The second layer is represented by the \texttt{MessageService} provides an interface to encrypt messages. It uses the \texttt{KeyServerService} to get access to keys. The third layer handles communication with the APIs of the underlying cloud messengers. It provides an abstract base class (\texttt{MessengerService}), from which classes that implement the communication to specific messengers can inherit. Finally, there is also a visual part, that displays the messages received from the \texttt{MessengerService}. It is visualized in Fig. \ref{fig:layers}

\begin{figure}[h!]
    \centering
    \includegraphics[width=0.8\columnwidth]{figures/layers.png}
    \caption{App Structure}
    \label{fig:layers}
\end{figure}

\subsection{Visual Part}

\todo{add screenshot}

\subsection{Peer to Peer}

Peer to peer messages are encrypted with a symmetric key, that is acquired through a Diffie-Hellman key agreement. This is implemented using the \texttt{TweetNaCl} library, a TypeScript implementation of the library Threema uses for its peer to peer chats \cite{Threema, TweetNaCl}. The library handles both key agreement and symmetric encryption.

The symmetric keys are acquired in the following way: First, it is checked if a key is already cached in the app, if not, the key server is checked for a symmetric key for this peer. If it is still no successful, the key server is queried for the \texttt{public\_enc} key of the peer. If it is present, a symmetric key is generated, using the \texttt{public\_enc} key of the peer and the \texttt{private\_enc} key of the user in question. The resulting symmetric key is then pushed to the key server. If the \texttt{public\_enc} key of the peer was not present on the server, it means that this peer does not use Athena yet, and the communication is continued in an unencrypted way.

\subsection{Groups}

Group messages are encrypted using a symmetric key, that is generated by one group member, and distributed to the others via the key server. For the message encryption, also the \texttt{TweetNaCl} library is used. In the current state of the app, only static groups are possible, which means that the constellation of members does not change. A system to modify group constellation is proposed in Section \todo{ref to future work}



To acquire the symmetric key, first the apps cache is checked. If unsuccessful, the key server is queried. If the server does not contain a valid symmetric key for this group, a new one is created and posted in the following way:

The app first generates a random symmetric key. To make it accessible to all members of the group, but only to them, the key has to be encrypted and posted to the key server. Since the group members do not possess a shared key yet, the key has to be encrypted for each member individually. To achieve this, the \texttt{public\_group} key of each member is used. This results in a list of \texttt{GroupKey} objects, see Section \ref{sec:group_keys}. This list is then posted to the key server. In the server, this data structure is called a \texttt{GroupPost}. However, if the key server would just provide a single slot for such a \texttt{GroupPost} per group, a malicious third party could just send random garbage to the server and fill this slot. This is possible, because the key server cannot know who is in which group, because it does not have access to the database of the underlying cloud messengers. Therefore, the key server cannot distinguish between a real group member and a user that is just pretending to be a member. To solve this issue, the key server maintains a list of \texttt{GroupPost} per group.

Users will always fetch the latest \texttt{GroupPost} first, and since the \texttt{GroupPost} object contains a field with the user ID of the poster, which is set by the key server, the users can easily detect if the \texttt{GroupPost} was posted by a user that is not a member of the group in question. If the post was from a malicious user, users can go through the list of \texttt{GroupPosts} chronologically until a valid post is found.

If a valid post was found, the user can go through the list of \texttt{GroupKeys}, until the entry for the user in question was found. The user can then decrypt the symmetric group key with its \texttt{private\_group} key.

\chapter{Future Work}
\label{sec:future_work}

\section{In Platform Authentication}

\section{Group Modifications}

% This displays the bibliography for all cited external documents. All references have to be defined in the file references.bib and can then be cited from within this document.
\bibliographystyle{IEEEtran}
\bibliography{references}

% This creates an appendix chapter, comment if not needed.
\appendix
\chapter{First Appendix Chapter Title}

\end{document}